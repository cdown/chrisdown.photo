<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Chris Down Photography</title>
  <meta name="description" content="Chris Down is a British wildlife photographer currently based in London, England.">

  <meta property="og:url" content="https://chrisdown.photo/">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Chris Down Photography">
  <meta property="og:description" content="Chris Down is a British wildlife photographer currently based in London, England.">
  <meta property="og:image" content="https://live.staticflickr.com/65535/53436051798_e570d53c2a_b.jpg">
  <meta name="twitter:card" content="summary">

  <style>
    :root {
      --navbar-height: 40px; /* update IMG_HEIGHTS if changed */
      --font-primary: 'Geomanist', sans-serif;
      --text-color: #333;
      --text-color-hover: #aaa;
      --transition-duration: 0.3s;
      --scroll-hint-size: 48px;
    }
    body {
      margin: 0;
      font-family: var(--font-primary);
    }
    .navbar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      top: 0;
      height: var(--navbar-height);
      margin: 0;
    }
    .navbar-menu {
      list-style: none;
      padding: 0;
    }
    .navbar-menu-item a {
      padding: 6px 20px;
      text-transform: lowercase;
      font-size: 20px;
      color: var(--text-color);
      text-decoration: none;
    }
    .navbar-menu-item a:hover {
      color: var(--text-color-hover);
    }
    .navbar-title {
      text-transform: lowercase;
      font-size: 20px;
      color: var(--text-color);
      text-decoration: none;
    }
    .navbar-title-full {
      display: inline;
    }
    .navbar-title-short {
      display: none;
    }
    @media (max-width: 500px) {
      .navbar-title-full {
        display: none;
      }
      .navbar-title-short {
        display: inline;
      }
    }
    .gallery-container {
      position: absolute;
      top: var(--navbar-height);
      left: 0;
      right: 0;
      bottom: 0;
      white-space: nowrap;
      overflow-x: auto;
      overflow-y: hidden;
      scrollbar-width: none;
      will-change: scroll-position;
    }
    .gallery-container::-webkit-scrollbar {
      display: none;
    }
    .gallery-container.no-scroll {
      pointer-events: none;
    }
    .gallery-item {
      display: inline-block;
      height: 100%;
      margin-right: -1px; /* Overlap by 1px to hide sub-pixel gaps */
    }
    /* The aspect ratio is now injected inline via style="aspect-ratio: w/h" */
    .gallery-image {
      width: auto;
      height: 100%;
      display: block;
      transition: opacity 0.5s ease-in-out;
      opacity: 0;
      object-fit: contain;
    }
    @keyframes arrowSideways {
      0% {
        transform: translateX(-50px) translateY(-50%);
        opacity: 0;
      }
      25% {
        transform: translateX(-50px) translateY(-50%);
        opacity: 1;
      }
      75% {
        transform: translateX(0) translateY(-50%);
        opacity: 1;
      }
      100% {
        transform: translateX(0) translateY(-50%);
        opacity: 0;
      }
    }
    @keyframes arrowDownwards {
      0% {
        transform: translateX(0) translateY(-25px);
        opacity: 0;
      }
      25% {
        transform: translateX(0) translateY(-25px);
        opacity: 1;
      }
      75% {
        transform: translateX(0) translateY(25px);
        opacity: 1;
      }
      100% {
        transform: translateX(0) translateY(25px);
        opacity: 0;
      }
    }
    .scroll-hint {
      position: fixed;
      top: 50%;
      right: 50px;
      z-index: 1000;
      color: #fff;
      text-shadow: -2px 0 #000, 0 2px #000, 2px 0 #000, 0 -2px #000;
      font-size: var(--scroll-hint-size);
      cursor: pointer;
      opacity: 0;
    }
    .about-content {
      display: flex;
    }
    #about-link {
      cursor: pointer;
    }
    /* The main overlay container is fixed, but does not itself scroll.
       Instead, it holds a separate scrollable area. */
    .about-overlay {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      max-width: 800px;
      z-index: 1000;
      visibility: hidden;
      opacity: 0;
      background-color: #fff;
    }
    .about-overlay.active {
      visibility: visible;
      opacity: 1;
    }
    /* This inner content area is the portion that scrolls. */
    .about-overlay-content {
      max-height: 60vh;
      overflow-y: auto;
      padding: 20px;
    }
    /* The close button is pinned to the top-right of the overlay. */
    .about-close {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #fff;
      border: none;
      font-size: 24px;
      cursor: pointer;
      color: var(--text-color);
    }
    .about-image {
      max-width: 50%;
      margin-right: 20px;
      object-fit: contain;
    }
    .about-text p {
      margin: 0 0 10px;
      line-height: 1.5;
      color: var(--text-color);
    }
    @media (max-width: 700px) {
      .about-content {
        display: block;
      }
      .about-overlay {
        width: 90%;
        box-sizing: border-box;
      }
      .about-image {
        margin: 0 auto 15px auto;
        max-width: 100%;
        display: block;
      }
      .about-text {
        text-align: left;
        margin: 0;
      }
    }
  </style>
</head>
<body>
  <nav class="navbar">
    <ul class="navbar-menu">
      <li class="navbar-menu-item">
        <a href="https://www.flickr.com/photos/chrisdown/albums/72157711447135721?layout=justified">flickr</a>
      </li>
    </ul>
    <a href="#gallery" class="navbar-title navbar-title-full">Chris Down Photography</a>
    <a href="#gallery" class="navbar-title navbar-title-short">Chris Down</a>
    <ul class="navbar-menu">
      <li class="navbar-menu-item">
        <a id="about-link">About</a>
      </li>
    </ul>
  </nav>

  <div class="gallery-container" id="gallery-container">{{ gallery_items }}</div>

  <div class="about-overlay" id="about-overlay">
    <button class="about-close" id="about-close">&times;</button>
    <div class="about-overlay-content">
      {{ about }}
    </div>
  </div>

  <div class="scroll-hint" id="scroll-hint">&#x2192;</div>

  <script>
    // Debug mode: enable additional logging if ?debug=1 is present
    const urlParams = new URLSearchParams(window.location.search);
    const debugMode = urlParams.get('debug') === '1';
    let debugBox = null;
    if (debugMode) {
      debugBox = document.createElement('div');
      debugBox.style.position = 'fixed';
      debugBox.style.top = '0';
      debugBox.style.right = '0';
      debugBox.style.backgroundColor = '#fff';
      debugBox.style.border = '1px solid #333';
      debugBox.style.padding = '10px';
      debugBox.style.zIndex = '9999';
      debugBox.style.color = '#000';
      debugBox.style.fontFamily = 'monospace';
      document.body.appendChild(debugBox);
    }
    const updateDebug = (msg) => {
      if (debugBox) {
        debugBox.innerText = msg;
      }
      console.log(msg);
    };

    const galleryContainer = document.getElementById('gallery-container');
    const scrollHint = document.getElementById('scroll-hint');
    const aboutLink = document.getElementById('about-link');
    const aboutOverlay = document.getElementById('about-overlay');
    const aboutClose = document.getElementById('about-close');

    // Variables for dragging and momentum
    let isDragging = false;
    let lastX = 0;
    let lastTime = 0;
    let velocity = 0;
    let momentumID = null;

    let fadedOut = false;
    let currentChosenHeight = 0;
    let images = [];

    // Load-pair arrays for image loading
    let loadPairs = [];
    let loadPairsIndex = 0;

    // For restoring scroll position on resize
    let scrollRatio = 0.5;
    let scrollingTimeout;
    let isResizing = false;

    let finishedInitialScroll = false;

    const availableHeights = [1040, 1400, 1760, 2120];

    // Duplicate gallery items to enable wrap-around scrolling
    const duplicateContent = () => {
      const items = Array.from(galleryContainer.children);
      items.forEach(item => {
        galleryContainer.appendChild(item.cloneNode(true));
      });
      updateDebug("Content duplicated for wrap-around.");
    };

    // Generates an offset sequence like [0, 1, -1, 2, -2, …]
    const generateOffsets = n => {
      if (n === 0) return [];
      let offsets = [0];
      for (let i = 1; offsets.length < n; i++) {
        offsets.push(-i);
        if (offsets.length < n) {
          offsets.push(i);
        }
      }
      return offsets;
    };

    // Build loadPairs from the unique images (first half)
    const buildLoadPairs = () => {
      loadPairs = [];
      loadPairsIndex = 0;
      const n = images.length / 2;
      const offsets = generateOffsets(n);
      offsets.forEach(offset => {
        const realIndex = offset >= 0 ? offset : n + offset;
        const duplicateIndex = realIndex < n ? realIndex + n : realIndex - n;
        loadPairs.push([realIndex, duplicateIndex]);
      });
      updateDebug("Load pairs built: " + JSON.stringify(loadPairs));
    };

    // Load the next pair of images (original + duplicate)
    const loadNextPair = () => {
      if (loadPairsIndex >= loadPairs.length) {
        return;
      }
      const pair = loadPairs[loadPairsIndex];
      const primaryIdx = pair[0];
      const image = images[primaryIdx];
      const imagePath = image.getAttribute(`data-${currentChosenHeight}`);
      if (!imagePath) {
        loadPairsIndex += 1;
        loadNextPair();
        return;
      }
      const img = new Image();
      img.addEventListener('load', () => {
        pair.forEach(idx => {
          images[idx].src = imagePath;
          images[idx].style.opacity = 1;
        });
        updateDebug("Loaded image: " + image.alt);
        loadPairsIndex += 1;
        loadNextPair();
      });
      img.addEventListener('error', () => {
        loadPairsIndex += 1;
        loadNextPair();
      });
      img.src = imagePath;
    };

    // Wrap-around functions
    const wrapScroll = () => {
      const left = galleryContainer.scrollWidth / 4;
      const right = (galleryContainer.scrollWidth / 4) * 3;
      const unduplicatedWidth = galleryContainer.scrollWidth / 2;
      if (galleryContainer.scrollLeft >= right) {
        updateDebug("Wrap-around: right edge reached.");
        galleryContainer.scrollLeft -= unduplicatedWidth;
      } else if (galleryContainer.scrollLeft <= left) {
        updateDebug("Wrap-around: left edge reached.");
        galleryContainer.scrollLeft += unduplicatedWidth;
      }
    };

    const ensureWraparound = scrollAmount => {
      const totalWidth = galleryContainer.scrollWidth / 2;
      let targetScrollLeft = galleryContainer.scrollLeft + scrollAmount;
      if (targetScrollLeft < 0) {
        const underflow = Math.abs(targetScrollLeft);
        targetScrollLeft = totalWidth - underflow;
      } else if (targetScrollLeft >= totalWidth) {
        const overflow = targetScrollLeft - totalWidth;
        targetScrollLeft = overflow;
      }
      galleryContainer.scrollLeft = targetScrollLeft;
    };

    // Scroll-hint functions
    let storedAnimation;
    const stopScrollHint = () => {
      if (!finishedInitialScroll || fadedOut) return;
      fadedOut = true;
      storedAnimation = scrollHint.style.animation;
      const stopAnimation = () => {
        scrollHint.style.animation = 'none';
        scrollHint.style.opacity = '0';
        scrollHint.style.visibility = 'hidden';
        scrollHint.removeEventListener('animationiteration', stopAnimation);
        scrollHint.removeEventListener('webkitAnimationIteration', stopAnimation);
      };
      scrollHint.addEventListener('animationiteration', stopAnimation);
      scrollHint.addEventListener('webkitAnimationIteration', stopAnimation);
    };

    const startScrollHint = () => {
      fadedOut = false;
      scrollHint.style.opacity = '1';
      scrollHint.style.visibility = 'visible';
      if (storedAnimation !== 'none') {
        scrollHint.style.animation = storedAnimation;
      }
    };

    // Adjust the image size if needed based on viewport height
    const loadBiggerImagesIfNeeded = () => {
      const screenHeightMinusNavbar = window.innerHeight - 50;
      let newChosenHeight = 0;
      for (const h of availableHeights) {
        if (screenHeightMinusNavbar <= h) {
          newChosenHeight = h;
          break;
        }
      }
      if (newChosenHeight === 0) {
        newChosenHeight = availableHeights[availableHeights.length - 1];
      }
      updateDebug("Image size change: current " + currentChosenHeight + ", required " + newChosenHeight);
      if (newChosenHeight > currentChosenHeight) {
        currentChosenHeight = newChosenHeight;
        images = [...document.querySelectorAll('.gallery-image')];
        buildLoadPairs();
        loadNextPair();
      }
    };

    // Set the scroll-hint arrow direction based on pointer type
    const setScrollHintDirection = () => {
      const isTouchDevice = window.matchMedia('(pointer: coarse)').matches;
      if (isTouchDevice) {
        scrollHint.innerHTML = '&#x2192;';
        scrollHint.style.animation = 'arrowSideways 1.5s infinite';
      } else {
        scrollHint.innerHTML = '&#x2193;';
        scrollHint.style.animation = 'arrowDownwards 1.5s infinite';
      }
    };

    const aboutIsOpen = () => {
      return aboutOverlay.classList.contains('active');
    };

    // ─── MOMENTUM SCROLLING ─────────────────────────────────────────────
    // When input is received we update velocity and scroll immediately.
    // The momentum loop decays the velocity smoothly.
    const startMomentumScroll = () => {
      if (!momentumID) {
        momentumID = requestAnimationFrame(momentumScroll);
      }
    };

    const momentumScroll = () => {
      if (Math.abs(velocity) < 0.5) {
        updateDebug("Momentum stopped. Final velocity: " + velocity);
        velocity = 0;
        momentumID = null;
        return;
      }
      galleryContainer.scrollLeft += velocity;
      wrapScroll();
      updateDebug("Momentum scrolling. Velocity: " + velocity + " | scrollLeft: " + galleryContainer.scrollLeft);
      velocity *= 0.95;
      momentumID = requestAnimationFrame(momentumScroll);
    };
    // ────────────────────────────────────────────────────────────────────

    // ─── WHEEL EVENT: 1:1 immediate movement with momentum deceleration ───
    galleryContainer.addEventListener('wheel', e => {
      e.preventDefault();
      if (aboutIsOpen()) return;
      // Log the wheel event details
      updateDebug("Wheel event: deltaY=" + e.deltaY + ", deltaMode=" + e.deltaMode);
      let delta = e.deltaY;
      // Convert line scrolling to pixels if needed
      if (e.deltaMode === 1) { 
        delta *= 33; 
      }
      galleryContainer.scrollLeft += delta;
      velocity += delta;
      wrapScroll();
      startMomentumScroll();
    });

    // ─── KEYBOARD EVENTS ────────────────────────────────────────────────
    document.addEventListener('keydown', e => {
      if (aboutIsOpen()) return;
      let change = 0;
      switch (e.key) {
        case 'ArrowLeft':
        case 'ArrowUp':
        case 'PageUp':
          change = -50;
          break;
        case 'ArrowRight':
        case 'ArrowDown':
        case 'PageDown':
          change = 50;
          break;
        default:
          return;
      }
      galleryContainer.scrollLeft += change;
      velocity += change;
      wrapScroll();
      startMomentumScroll();
    });

    // ─── SCROLL EVENT (for wrap-around and saving position) ─────────────
    let lastScrollFire = 0;
    galleryContainer.addEventListener('scroll', () => {
      const now = performance.now();
      if (now - lastScrollFire > 50) {
        wrapScroll();
        stopScrollHint();
        saveScrollPosition();
        lastScrollFire = now;
      }
    });

    scrollHint.addEventListener('click', () => {
      galleryContainer.scrollLeft += -50;
      wrapScroll();
      saveScrollPosition();
    });

    // ─── TOUCH EVENTS: Immediate 1:1 dragging with momentum on release ─────
    galleryContainer.addEventListener('touchstart', e => {
      if (aboutIsOpen()) return;
      if (momentumID) {
        cancelAnimationFrame(momentumID);
        momentumID = null;
      }
      isDragging = true;
      lastX = e.touches[0].pageX - galleryContainer.offsetLeft;
      lastTime = Date.now();
      velocity = 0;
      updateDebug("Touchstart: lastX=" + lastX + ", time=" + lastTime);
    });

    galleryContainer.addEventListener('touchmove', e => {
      e.preventDefault();
      if (aboutIsOpen() || !isDragging) return;
      const currentX = e.touches[0].pageX - galleryContainer.offsetLeft;
      const delta = lastX - currentX;
      galleryContainer.scrollLeft += delta;
      wrapScroll();
      const currentTime = Date.now();
      const dt = currentTime - lastTime;
      if (dt > 0) {
        velocity = delta / dt;
      }
      updateDebug("Touchmove: delta=" + delta + ", velocity=" + velocity);
      lastX = currentX;
      lastTime = currentTime;
      saveScrollPosition();
    });

    const endTouch = () => {
      isDragging = false;
      updateDebug("Touchend: Starting momentum with velocity=" + velocity);
      startMomentumScroll();
    };

    galleryContainer.addEventListener('touchend', endTouch);
    galleryContainer.addEventListener('touchcancel', endTouch);

    // ─── INITIALIZATION ─────────────────────────────────────────────────
    document.addEventListener('DOMContentLoaded', () => {
      duplicateContent();
      loadBiggerImagesIfNeeded();
      setScrollHintDirection();
      galleryContainer.scrollLeft = galleryContainer.scrollWidth / 2;
      saveScrollPosition();
      const onFirstScroll = () => {
        finishedInitialScroll = true;
        galleryContainer.removeEventListener('scroll', onFirstScroll);
      };
      galleryContainer.addEventListener('scroll', onFirstScroll, { once: true });
    });

    window.addEventListener('resize', loadBiggerImagesIfNeeded);
    window.addEventListener('resize', () => {
      isResizing = true;
      restoreScrollPosition();
      clearTimeout(scrollingTimeout);
      scrollingTimeout = setTimeout(() => {
        isResizing = false;
      }, 200);
    });

    const saveScrollPosition = () => {
      if (isResizing) return;
      clearTimeout(scrollingTimeout);
      scrollingTimeout = setTimeout(() => {
        const totalScrollableWidth = galleryContainer.scrollWidth - galleryContainer.clientWidth;
        scrollRatio = totalScrollableWidth > 0 ? galleryContainer.scrollLeft / totalScrollableWidth : 0;
        updateDebug("Saving scroll ratio: " + scrollRatio);
      }, 100);
    };

    const restoreScrollPosition = () => {
      const totalScrollableWidth = galleryContainer.scrollWidth - galleryContainer.clientWidth;
      galleryContainer.scrollLeft = scrollRatio * totalScrollableWidth;
      updateDebug("Restoring scroll ratio: " + scrollRatio);
    };

    aboutLink.addEventListener('click', () => {
      aboutOverlay.classList.add('active');
      galleryContainer.classList.add('no-scroll');
      document.body.style.overflow = 'hidden';
      stopScrollHint();
    });

    aboutClose.addEventListener('click', () => {
      aboutOverlay.classList.remove('active');
      galleryContainer.classList.remove('no-scroll');
      document.body.style.overflow = '';
    });
  </script>
</body>
</html>
